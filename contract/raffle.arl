archetype raffle(
  owner        : address,
  jackpot      : tez,
  ticket_price : tez
)

variable open_buy      : option<date> = none
variable close_buy     : option<date> = none
variable close_reveal  : option<date> = none
variable open_transfer : option<date> = none

variable chest_time   : option<nat>  = none
variable reveal_fee   : option<rational> = none

asset player {
  id                 : address;
  locked_raffle_key  : chest;
  revealed           : bool = false;
}

variable raffle_key  : nat = 0

states =
| Created initial
| Initialised
| Transferred

transition initialise(ob : date, cb : date, cr : date, ot : date, t : nat, rf : rational) {
  called by owner
  require {
    r0 : now <= ob < cb < cr    otherwise "INVALID_OPEN_CLOSE_BUY_REVEAL";
    r1 : cb - ob <= ot - cr     otherwise "INVALID_DECRYPT_DURATION";
    r2 : rf <= 1                otherwise "INVALID_REVEAL_FEE";
    r3 : transferred = jackpot  otherwise "INVALID_AMOUNT"
  }
  from Created to Initialised
  with effect {
    open_buy      := some(ob);
    close_buy     := some(cb);
    close_reveal  := some(cr);
    open_transfer := some(ot);
    chest_time    := some(t);
    reveal_fee    := some(rf)
  }
}

entry buy (lrk : chest) {
  state is Initialised
  require {
    r4 : transferred = ticket_price                     otherwise "INVALID_TICKET_PRICE";
    r5 : opt_get(open_buy) < now < opt_get(close_buy)   otherwise "BUY_CLOSED"
  }
  effect { player.add({ id = caller; locked_raffle_key = lrk }) }
}

function is_valid_reveal_time(addr : address) : bool {
  return (
    if caller = addr then
      opt_get(close_buy) < now < opt_get(close_reveal)
    else
      opt_get(close_reveal) < now < opt_get(open_transfer)
  )
}

entry reveal(addr : address, k : chest_key) {
  state is Initialised
  require {
    r6 : is_valid_reveal_time(addr) otherwise "INVALID_REVEAL_TIME";
    r7 : not player[addr].revealed  otherwise "PLAYER_ALREADY_REVEALED"
  }
  effect {
    match open_chest(k, player[addr].locked_raffle_key, opt_get(chest_time)) with
    | left (unlocked) -> begin
        match unpack<nat>(unlocked) with
        | some(partial_key) ->
          raffle_key += partial_key;
          player[addr].revealed := true
        | none -> player.remove(addr)
        end;
        transfer (opt_get(reveal_fee) * ticket_price) to caller;
      end
    | right(chest_key_error) -> begin
       if chest_key_error then
        fail("INVALID_CHEST_KEY")
       else
        player.remove(addr);
        transfer (opt_get(reveal_fee) * ticket_price) to caller
      end
    end
  }
}

transition %transfer() {
  require {
    r8: player.select(the.revealed).count() = player.count() or
        opt_get(open_transfer) < now
  }
  from Initialised to Transferred
  with effect {
    player.removeif(not the.revealed);
    transfer balance to player.nth(raffle_key % player.count());
  }
}

