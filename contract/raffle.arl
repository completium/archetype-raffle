archetype raffle(
  owner        : address,
  min_duration : duration,
  jackpot      : tez,
  ticket_price : tez
)

variable reveal_fee : option<rational> = none

variable close_date : option<date> = none
variable chest_time : option<nat>  = none

asset player {
  id                 : address;
  locked_raffle_key  : chest;
  revealed           : bool = false;
}

variable raffle_key  : nat = 0
variable nb_revealed : nat = 0

states =
| Created initial
| Running
| Transferred

transition open(cd : date, t : nat, rf : rational) {
  called by owner
  require {
    r0 : now + min_duration < cd   otherwise "INVALID_CLOSE_DATE";
    r1 : rf < 1                    otherwise "INVALID_REVEAL_FEE";
    r2 : transferred = jackpot     otherwise "INVALID_AMOUNT"
  }
  from Created to Running
  with effect {
    close_date        := some(cd);
    chest_time        := some(t);
    reveal_fee        := some(rf)
  }
}

entry buy (lrk : chest) {
  state is Running
  require {
    r3 : transferred = ticket_price otherwise "INVALID_TICKET_PRICE";
    r4 : now < opt_get(close_date)  otherwise "RAFFLE_CLOSED"
  }
  effect { player.add({ id = caller; locked_raffle_key = lrk }) }
}

transition transfer_jackpot() {
  called by selfaddress
  from Running to Transferred
  with effect {
    transfer balance to player.nth(raffle_key % player.count());
    player.clear()
  }
}

entry reveal(addr : address, k : chest_key) {
  state is Running
  require {
    r5 : now > opt_get(close_date) otherwise "RAFFLE_OPEN";
    r6 : not player[addr].revealed otherwise "PLAYER_ALREADY_REVEALED"
  }
  effect {
    match open_chest(k, player[addr].locked_raffle_key, opt_get(chest_time)) with
    | left (unlocked) -> raffle_key += opt_get(unpack<nat>(unlocked))
    | right(error)    -> fail("INVALID_TIMELOCK")
    end;
    nb_revealed += 1;
    player[addr].revealed := true;
    if nb_revealed = player.count() then
      transfer 0tz to entry self.transfer_jackpot();
    transfer (opt_get(reveal_fee) * ticket_price) to caller;
  }
}


