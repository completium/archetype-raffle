archetype raffle(
  owner        : address,
  min_duration : duration,
  jackpot      : tez,
  ticket_price : tez,
  reveal_fee   : rational)

variable close_date        : option<date>   = none
variable desc              : option<string> = none

asset player {
  id                : address;
  locked_raffle_key : chest;
  raffle_key        : option<nat> = none
}

states =
| Created initial
| Running
| Transferred

transition open(cd : date, d : string) {
  called by owner
  require {
    r0 : now + min_duration < cd   otherwise "INVALID_CLOSE_DATE";
    r1 : transferred = jackpot     otherwise "INVALID_AMOUNT"
  }
  from Created to Running
  with effect {
    close_date        := some(cd);
    desc              := some(d);
  }
}

entry buy (lrk : chest) {
  state is Running
  require {
    r2 : transferred = ticket_price otherwise "INVALID_TICKET_PRICE";
    r3 : now < opt_get(close_date)  otherwise "RAFFLE_CLOSED"
  }
  effect { player.add({ id = caller; locked_raffle_key = lrk }) }
}

entry reveal(pl : address, k : chest_key, time : nat) {
  require {
    r4 : now > opt_get(close_date) otherwise "RAFFLE_OPEN";
  }
  effect {
    match open_chest(k, player[pl].locked_raffle_key, time) with
    | left (unlocked) -> player[pl].raffle_key := unpack<nat>(unlocked)
    | right(error)    -> fail("INVALID_TIMELOCK")
    end;
    transfer (reveal_fee * ticket_price) to caller
  }
}

transition transfer_jackpot(k : chest_key, time : nat) {
  require {
    r5 : now > opt_get(close_date) otherwise "RAFFLE_OPEN";
    r6 : player.select(issome(the.raffle_key)).count() = player.count()
  }
  from Running to Transferred
  with effect {
    var global_raffle_key = player.sum(opt_get(the.raffle_key));
    transfer balance to player.nth(global_raffle_key % player.count());
    player.clear()
  }
}

