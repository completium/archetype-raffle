archetype raffle(owner: address, min_duration : duration, jackpot : tez, ticket_price : tez)

variable locked_raffle_key : option<chest>  = none
variable close_date        : option<date>   = none
variable desc              : option<string> = none

asset player {
  id : address
}

states =
| Created initial
| Running
| Transferred

transition open(cd : date, d : string, lrk : chest) {
  called by owner
  require {
    r0 : now + min_duration < cd   otherwise "INVALID_CLOSE_DATE";
    r1 : transferred = jackpot     otherwise "INVALID_AMOUNT"
  }
  from Created to Running
  with effect {
    locked_raffle_key := some(lrk);
    close_date        := some(cd);
    desc              := some(d);
  }
}

entry buy () {
  state is Running
  require {
    r2 : transferred = ticket_price otherwise "INVALID_TICKET_PRICE";
    r3 : now < opt_get(close_date)  otherwise "RAFFLE_CLOSED"
  }
  effect { player.add({ caller }) }
}

enum unlock_result =
| Success<nat>
| Fail<string>

function unlock_raffle_key(k : chest_key, time : nat) : unlock_result {
  return (
    match open_chest(k, opt_get(locked_raffle_key), time) with
    | left(unlocked) ->
      match unpack<nat>(unlocked) with
      | some(raffle_key) -> Success(raffle_key)
      | none -> Fail("INVALID_RAFFLE_KEY_TYPE")
      end
    | right(v) -> if v then Fail("INVALID_TIMELOCK") else Fail("INVALID_CHEST_KEY")
    end)
}

transition transfer_jackpot(k : chest_key, time : nat) {
  require {
    r4 : now > opt_get(close_date) otherwise "RAFFLE_OPEN";
  }
  from Running to Transferred
  with effect {
    match unlock_raffle_key(k, time) with
    | Success(raffle_key) -> begin
        transfer jackpot to player.nth(raffle_key % player.count());
        transfer (balance - jackpot) to owner;
        player.clear()
      end
    | Fail(error) -> fail(error)
    end
  }
}

